%========================================================================
\section{Hecatonchires简介}
%========================================================================
\subsection{用途}
Hecatonchires是metis项目的一个子项目，这个项目是用java编写的，主要用于解决metis中实时排名产生大量计算任务的问题。Hecatonchires是一个采用Master/Slave架构的分布式计算程序。

运行时，在服务器上运行一个叫MasterNode的线程，而在若干个client上分别运行一个SlaveNode线程。MasterNode主要负责：管理所有的slave，包括身份验证、ip管理、心跳管理、查找任务、分配任务。当client的SlaveNode启动后，它需要等待Master分配给他任务，完成任务后把结果发给服务器。并且在这过程中，slave要每隔一段时间发送一个心跳给master，以保证master知道哪些slave在等待，而哪些slave已经关闭。

\subsection{SlaveNode原理}
SlaveNode的结构比较简单，他主要包含两个线程TaskListener和HeartBeatSender。当启动的时候，SlaveNode会首先自动给Master发送注册请求，接着创建TaskListener和HeartBeatSender。

HeartBeatSender负责每隔一段时间，跟Master做一次心跳以确认双方的信息是否正确。如果HeartBeatSender获得Master通知发现双方存在不一致问题，则会强行终止SlaveNode。

TaskListener会开启一个ServerSocket监听Master发给他的信息，一旦接受了Master的任务，TaskListener会马上开始进行处理，完成后上传结果给服务器。这里TaskListener是但线程的，所以他在处理这个任务的时候是无法监听到任何socket，而这也是不应该发生的。

\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{slave.jpg}
\caption{slave状态机}
\label{fig:MasterNod}
\end{figure} 

如上图所示，slave首先处于init状态，当slave成功调用register后，进入waiting状态，当TaskListener接收到master的任务后，进入working状态。working的原理是把task需要的文件放入一个安全的目录中并调用shell指令make。如果发现slave缺少这些文件，会进入getfile状态，向master请求文件，当该文件请求到后，继续working。当评测结束后，进入submit状态向master上传文件。当所有文件上传后，report给master告诉master这个任务处理完成了，然后进入waiting状态。

\subsection{MasterNode原理}
\begin{figure}[htbp]
\centering
\includegraphics[width=12cm]{MasterNode.jpg}
\caption{MasterNode结构图}
\label{fig:MasterNode}
\end{figure} 

MasterNode的整体结构如上图所示。其中方框代表一类线程，圆圈代表一个数据结构，菱形代表数据库。

其中，所有的Slave的信息都存储在SlaveFacltory，这些信息包括ip地址、认证id、id级别（id级别请参照后面章节的介绍）、心跳时间等，并由其统一提供接口进行访问。所有的任务的信息保存在TaskFactory中，包括评测优先级和传输内容等等。SlaveFactory的所有的函数都是串行的，以维持数据的一致性。所以若非必要，应该尽量减少对其函数的调用次数，TaskFactory与之相同。

MasterListener主要是管理一个ServerSocket，这个ServerSocket固定监听一个接口（接口号请参照“参数设置”章节）。当监听到一个Socket请求后，MasterListener将创建SocketFilter线程，并将这个socket交给SocketFilter线程来处理。

SocketFilter主要是根据Socket中的信息来确定不同的通信请求，包括注册请求、心跳确认、文件接收、文件下载、结果上传五种，其中，注册请求、心跳确认、结果上传三种都需要调用SlaveFactory的接口而结果上传需要调用数据库。

TaskProducer主要是用于产生任务并把它放入TaskFactory中。TaskProducer工作时首先会查看SlaveFtory中是否有需要被回收的任务，如果有，则把他们全部回收，然后查看数据库，看数据库中是否有任务需要评测并且之前没有被TaskProducer侦测到。然后把他们插入TaskFactory中。

TaskDivider用于把任务分发给正在等待任务的slave。首先，TaskDivider会从TaskFactory中提取一个Task，然后查看SlaveFactory，并获取到这个SlaveFactory的ip地址，接着其会创建一个TaskSender的线程将这个task和ip地址转交给TaskSender。

TaskSender把task对应的数据发送给处理这个task的id。


